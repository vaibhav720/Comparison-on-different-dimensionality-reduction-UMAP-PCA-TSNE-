# -*- coding: utf-8 -*-
"""assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lkqscAkM2YzOZGFg2fqIqbqqD0EsVBGE
"""

!pip install umap-learn

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import pandas as pd
import keras
from keras import layers
from keras.utils import to_categorical
from random import randint


(x_train, y_train), (x_test, y_test) = tf.keras.datasets.fashion_mnist.load_data()

print("x_train shape:", x_train.shape, "y_train shape:", y_train.shape)

x_train_flat = x_train.reshape(x_train.shape[0], -1)
x_test_flat = x_test.reshape(x_test.shape[0], -1)
y_train_flat = y_train.reshape(y_train.shape[0], -1)
y_test_flat = y_test.reshape(y_test.shape[0], -1)

x_train_flat = x_train_flat / 255.0
x_test_flat = x_test_flat / 255.0

class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

plt.figure(figsize=(10, 10))
for i in range(25):
    plt.subplot(5, 5, i + 1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(x_train[i], cmap=plt.cm.binary)
    plt.xlabel(class_names[y_train[i]])
plt.show()

class PCA_and_CNN:
  def __init__(self):
    pca_model = PCA(n_components=min(x_train_flat.shape[0], x_train_flat.shape[1]))

    x_train_pca_data = pca_model.fit_transform(x_train_flat)
    x_test_pca = pca_model.transform(x_test_flat)

    plt.figure(figsize=(10, 10))
    for i in range(10):
        plt.scatter(x_train_pca_data[y_train == i, 0], x_train_pca_data[y_train == i, 1], label=class_names[i])
    plt.title('PCA MNIST ')
    plt.xlabel('Component 1')
    plt.ylabel('Component 2')
    plt.legend()
    plt.show()
    self.x_train_cnn = x_train_pca_data.reshape((-1, 28, 28, 1))
    self.x_test_cnn = x_test_pca.reshape((-1, 28, 28, 1))


  def CNN(self):
    model = models.Sequential([
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
        layers.MaxPooling2D((2, 2)),
        layers.Conv2D(64, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),
        layers.Conv2D(64, (3, 3), activation='relu'),
        layers.Flatten(),
        layers.Dense(64, activation='relu'),
        layers.Dense(10, activation='softmax')
    ])

    model.compile(optimizer='adam',
                  loss='sparse_categorical_crossentropy',
                  metrics=['accuracy'])

    history = model.fit(self.x_train_cnn, y_train, epochs=3, validation_data=(self.x_test_cnn, y_test))

    plt.figure(figsize=(10, 6))
    plt.plot(history.history['accuracy'], label='accuracy')
    plt.plot(history.history['val_accuracy'], label='val_accuracy')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.title('Training and Validation Accuracy')
    plt.legend()
    plt.show()

    test_loss, test_accuracy = model.evaluate(self.x_test_cnn, y_test)

    print(f"Test Loss: {test_loss}")
    print(f"Test Accuracy: {test_accuracy}")

pca_and_cnn = PCA_and_CNN()
pca_and_cnn.CNN()

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import fetch_openml
from sklearn.preprocessing import StandardScaler
from umap import UMAP

class UMAP_and_CNN:
  def __init__(self):
    umap = UMAP(n_components=50)
    umap_results = umap.fit_transform(x_train_flat)
    umap_test = umap.fit_transform(x_test_flat)
    plt.figure(figsize=(10, 6))
    plt.scatter(umap_results[:, 0], umap_results[:, 1], c=y_train_flat, cmap='tab10', s=5)
    plt.title('UMAP Visualization of MNIST Fashion Dataset')
    plt.xlabel('UMAP Component 1')
    plt.ylabel('UMAP Component 2')
    plt.colorbar(label='Label')
    plt.show()
    self.x_train_cnn = umap_results.reshape((-1, 10, 5, 1))
    self.x_test_cnn = umap_test.reshape((-1, 10, 5, 1))


  def CNN(self):
    model = models.Sequential([
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(10, 5, 1)),
        layers.Conv2D(32, (3, 3), activation='relu', padding='same'),
        layers.MaxPooling2D((1, 1), padding='valid', strides=(1, 1)),
        layers.Conv2D(64, (3, 3), activation='relu', padding='same'),
        layers.Conv2D(64, (3, 3), activation='relu', padding='same'),
        layers.MaxPooling2D((1, 1), padding='valid', strides=(1, 1)),
        layers.Conv2D(128, (3, 3), activation='relu', padding='same'),
        layers.Conv2D(128, (3, 3), activation='relu', padding='same'),
        layers.MaxPooling2D((1, 1), padding='valid', strides=(1, 1)),
        layers.Flatten(),
        layers.Dense(64, activation='relu'),
        layers.Dense(10, activation='softmax')
    ])
    model.compile(optimizer='adam',
                  loss='sparse_categorical_crossentropy',
                  metrics=['accuracy'])

    history = model.fit(self.x_train_cnn, y_train, epochs=1, validation_data=(self.x_test_cnn, y_test))

    plt.figure(figsize=(10, 6))
    plt.plot(history.history['accuracy'], label='accuracy')
    plt.plot(history.history['val_accuracy'], label='val_accuracy')
    plt.xlabel('Epoch')
    plt.ylabel('Accuracy')
    plt.title('Training and Validation Accuracy')
    plt.legend()
    plt.show()

    test_loss, test_accuracy = model.evaluate(self.x_test_cnn, y_test)

    print(f"Test Loss: {test_loss}")
    print(f"Test Accuracy: {test_accuracy}")
umap_and_cnn = UMAP_and_CNN()
umap_and_cnn.CNN()

(x_train, y_train), (x_test, y_test) = tf.keras.datasets.fashion_mnist.load_data()

print("x_train shape:", x_train.shape, "y_train shape:", y_train.shape)

x_train_flat = x_train.reshape(x_train.shape[0], -1)
x_test_flat = x_test.reshape(x_test.shape[0], -1)
y_train_flat = y_train.reshape(y_train.shape[0], -1)
y_test_flat = y_test.reshape(y_test.shape[0], -1)

x_train_flat = x_train_flat / 255.0
x_test_flat = x_test_flat / 255.0

class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

plt.figure(figsize=(10, 10))
for i in range(25):
    plt.subplot(5, 5, i + 1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(x_train[i], cmap=plt.cm.binary)
    plt.xlabel(class_names[y_train[i]])
plt.show()

class TSNE_and_CNN:
  def __init__(self):
    tsne = TSNE(n_components=2)

    tsne_results_train = tsne.fit_transform(x_train_flat)
    tsne_results_test = tsne.fit_transform(x_test_flat)
    print(tsne_results_train.shape)
    plt.figure(figsize=(10, 6))
    plt.scatter(tsne_results_train[:, 0], tsne_results_train[:, 1], c=y_train, cmap='tab10', s=5)
    plt.title('t-SNE  (Training Set)')
    plt.xlabel('t-SNE Component 1')
    plt.ylabel('t-SNE Component 2')
    plt.colorbar(label='Label')
    plt.show()

    plt.figure(figsize=(10, 6))
    plt.scatter(tsne_results_test[:, 0], tsne_results_test[:, 1], c=y_test, cmap='tab10', s=5)
    plt.title('t-SNE  (Test Set)')
    plt.xlabel('t-SNE Component 1')
    plt.ylabel('t-SNE Component 2')
    plt.colorbar(label='Label')
    plt.show()

    self.x_train = x_train_flat.reshape((-1, 28, 28, 1))
    self.x_test = x_test_flat.reshape((-1, 28, 28, 1))



  def CNN(self):


    assert len(self.x_train) == len(y_train), "Number of samples and labels should match"

    num_classes = 10
    y_train = to_categorical(y_train, num_classes=num_classes)
    y_test = to_categorical(y_test, num_classes=num_classes)

    model = keras.Sequential()
    model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Conv2D(64, (3, 3), activation='relu'))
    model.add(layers.MaxPooling2D((2, 2)))
    model.add(layers.Flatten())
    model.add(layers.Dense(64, activation='relu'))
    model.add(layers.Dense(num_classes, activation='softmax'))

    model.compile(optimizer='adam',
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])

    model.fit(x_train, y_train, epochs=10, validation_data=(x_test, y_test))

    test_loss, test_accuracy = model.evaluate(x_test, y_test)
    print('Test accuracy:', test_accuracy)
tsne_and_cnn = TSNE_and_CNN()
tsne_and_cnn.CNN()